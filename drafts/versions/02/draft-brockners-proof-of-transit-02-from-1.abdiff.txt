
INTRODUCTION, paragraph 1:
EXPLANATION: 

OLD:

 Network Working Group                                       F. Brockners
 Internet-Draft                                               S. Bhandari
 Intended status: Experimental                                    S. Dara
|Expires: January 19, 2017                                   C. Pignataro
                                                                    Cisco
                                                                 J. Leddy
                                                                  Comcast
                                                                S. Youell
                                                                     JMPC
|                                                           July 18, 2016

NEW:

 Network Working Group                                       F. Brockners
 Internet-Draft                                               S. Bhandari
 Intended status: Experimental                                    S. Dara
|Expires: May 3, 2017                                        C. Pignataro
                                                                    Cisco
                                                                 J. Leddy
                                                                  Comcast
                                                                S. Youell
                                                                     JMPC
|                                                        October 30, 2016


------------------------------------------------------------------------


INTRODUCTION, paragraph 2:
EXPLANATION: 

OLD:

                             Proof of Transit
|                  draft-brockners-proof-of-transit-01

NEW:

                             Proof of Transit
|                  draft-brockners-proof-of-transit-02


------------------------------------------------------------------------


INTRODUCTION, paragraph 4:
EXPLANATION: 

OLD:

|   Several technologies such as traffic engineering, service function
|   chaining, or policy based routing, are used to steer traffic through
|   a specific, user-defined path.  This document defines mechanisms to
|   securely prove that traffic transited the defined path.  The
|   mechanisms allow to securely verify whether all packets traversed all
|   those nodes of a given path that they are supposed to visit.

NEW:

|   Several technologies such as Traffic Engineering (TE), Service
|   Function Chaining (SFC), and policy based routing are used to steer
|   traffic through a specific, user-defined path.  This document defines
|   mechanisms to securely prove that traffic transited said defined
|   path.  These mechanisms allow to securely verify whether, within a
|   given path, all packets traversed all the nodes that they are
|   supposed to visit.


------------------------------------------------------------------------


INTRODUCTION, paragraph 9:
EXPLANATION: 

OLD:

|   This Internet-Draft will expire on January 19, 2017.

NEW:

|   This Internet-Draft will expire on May 3, 2017.


------------------------------------------------------------------------


Section 3., paragraph 0:
EXPLANATION: 

OLD:

    1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
    2.  Conventions . . . . . . . . . . . . . . . . . . . . . . . . .   4
    3.  Proof of Transit  . . . . . . . . . . . . . . . . . . . . . .   4
      3.1.  Basic Idea  . . . . . . . . . . . . . . . . . . . . . . .   5
|     3.2.  Solution Approach . . . . . . . . . . . . . . . . . . . .   5
        3.2.1.  Setup . . . . . . . . . . . . . . . . . . . . . . . .   6
        3.2.2.  In Transit  . . . . . . . . . . . . . . . . . . . . .   6
|       3.2.3.  Verification  . . . . . . . . . . . . . . . . . . . .   6
|     3.3.  Example for Illustration  . . . . . . . . . . . . . . . .   7
        3.3.1.  Basic Version . . . . . . . . . . . . . . . . . . . .   7
          3.3.1.1.  Secret Shares . . . . . . . . . . . . . . . . . .   7
          3.3.1.2.  Lagrange Polynomials  . . . . . . . . . . . . . .   7
          3.3.1.3.  LPC Computation . . . . . . . . . . . . . . . . .   8
          3.3.1.4.  Reconstruction  . . . . . . . . . . . . . . . . .   8
|         3.3.1.5.  Verification  . . . . . . . . . . . . . . . . . .   8
        3.3.2.  Enhanced Version  . . . . . . . . . . . . . . . . . .   9
          3.3.2.1.  Random Polynomial . . . . . . . . . . . . . . . .   9
          3.3.2.2.  Reconstruction  . . . . . . . . . . . . . . . . .   9
          3.3.2.3.  Verification  . . . . . . . . . . . . . . . . . .  10
      3.4.  Operational Aspects . . . . . . . . . . . . . . . . . . .  10
|   4.  Sizing the Data for Proof of Transit  . . . . . . . . . . . .  11
|   5.  Node Configuration  . . . . . . . . . . . . . . . . . . . . .  12
|     5.1.  Procedure . . . . . . . . . . . . . . . . . . . . . . . .  12
|     5.2.  YANG Model  . . . . . . . . . . . . . . . . . . . . . . .  12
|   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  15
|   7.  Manageability Considerations  . . . . . . . . . . . . . . . .  15
|   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  16
|     8.1.  Proof of Transit  . . . . . . . . . . . . . . . . . . . .  16
|     8.2.  Anti Replay . . . . . . . . . . . . . . . . . . . . . . .  16
|     8.3.  Anti Tampering  . . . . . . . . . . . . . . . . . . . . .  16
|     8.4.  Recycling . . . . . . . . . . . . . . . . . . . . . . . .  17
|     8.5.  Redundant Nodes and Failover  . . . . . . . . . . . . . .  17
|     8.6.  Controller Operation  . . . . . . . . . . . . . . . . . .  17
|     8.7.  Verification Scope  . . . . . . . . . . . . . . . . . . .  17
|       8.7.1.  Node Ordering . . . . . . . . . . . . . . . . . . . .  18
|       8.7.2.  Stealth Nodes . . . . . . . . . . . . . . . . . . . .  18
|   9.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  18
|   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  18
|     10.1.  Normative References . . . . . . . . . . . . . . . . . .  18
|     10.2.  Informative References . . . . . . . . . . . . . . . . .  18
|   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  19

NEW:

    1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
    2.  Conventions . . . . . . . . . . . . . . . . . . . . . . . . .   4
    3.  Proof of Transit  . . . . . . . . . . . . . . . . . . . . . .   4
      3.1.  Basic Idea  . . . . . . . . . . . . . . . . . . . . . . .   5
|     3.2.  Solution Approach . . . . . . . . . . . . . . . . . . . .   6
        3.2.1.  Setup . . . . . . . . . . . . . . . . . . . . . . . .   6
        3.2.2.  In Transit  . . . . . . . . . . . . . . . . . . . . .   6
|       3.2.3.  Verification  . . . . . . . . . . . . . . . . . . . .   7
|     3.3.  Illustrative Example  . . . . . . . . . . . . . . . . . .   7
        3.3.1.  Basic Version . . . . . . . . . . . . . . . . . . . .   7
          3.3.1.1.  Secret Shares . . . . . . . . . . . . . . . . . .   7
          3.3.1.2.  Lagrange Polynomials  . . . . . . . . . . . . . .   7
          3.3.1.3.  LPC Computation . . . . . . . . . . . . . . . . .   8
          3.3.1.4.  Reconstruction  . . . . . . . . . . . . . . . . .   8
|         3.3.1.5.  Verification  . . . . . . . . . . . . . . . . . .   9
        3.3.2.  Enhanced Version  . . . . . . . . . . . . . . . . . .   9
          3.3.2.1.  Random Polynomial . . . . . . . . . . . . . . . .   9
          3.3.2.2.  Reconstruction  . . . . . . . . . . . . . . . . .   9
          3.3.2.3.  Verification  . . . . . . . . . . . . . . . . . .  10
      3.4.  Operational Aspects . . . . . . . . . . . . . . . . . . .  10
|     3.5.  Alternative Approach  . . . . . . . . . . . . . . . . . .  11
|       3.5.1.  Basic Idea  . . . . . . . . . . . . . . . . . . . . .  11
|       3.5.2.  Pros  . . . . . . . . . . . . . . . . . . . . . . . .  11
|       3.5.3.  Cons  . . . . . . . . . . . . . . . . . . . . . . . .  12
|   4.  Sizing the Data for Proof of Transit  . . . . . . . . . . . .  12
|   5.  Node Configuration  . . . . . . . . . . . . . . . . . . . . .  13
|     5.1.  Procedure . . . . . . . . . . . . . . . . . . . . . . . .  13
|     5.2.  YANG Model  . . . . . . . . . . . . . . . . . . . . . . .  14
|   6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  17
|   7.  Manageability Considerations  . . . . . . . . . . . . . . . .  17
|   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  17
|     8.1.  Proof of Transit  . . . . . . . . . . . . . . . . . . . .  17
|     8.2.  Cryptanalysis . . . . . . . . . . . . . . . . . . . . . .  18
|     8.3.  Anti-Replay . . . . . . . . . . . . . . . . . . . . . . .  18
|     8.4.  Anti-Preplay  . . . . . . . . . . . . . . . . . . . . . .  19
|     8.5.  Anti-Tampering  . . . . . . . . . . . . . . . . . . . . .  19
|     8.6.  Recycling . . . . . . . . . . . . . . . . . . . . . . . .  19
|     8.7.  Redundant Nodes and Failover  . . . . . . . . . . . . . .  19
|     8.8.  Controller Operation  . . . . . . . . . . . . . . . . . .  20
|     8.9.  Verification Scope  . . . . . . . . . . . . . . . . . . .  20
|       8.9.1.  Node Ordering . . . . . . . . . . . . . . . . . . . .  20
|       8.9.2.  Stealth Nodes . . . . . . . . . . . . . . . . . . . .  21
|   9.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  21
|   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  21
|     10.1.  Normative References . . . . . . . . . . . . . . . . . .  21
|     10.2.  Informative References . . . . . . . . . . . . . . . . .  21
|   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21


------------------------------------------------------------------------


Section 1., paragraph 1:
EXPLANATION: 

OLD:

|   Several deployments use traffic engineering, policy routing, segment
|   routing or Service Function Chaining (SFC) [RFC7665] to steer packets
|   through a specific set of nodes.  In certain cases regulatory
|   obligations or a compliance policy require operators to prove that
|   all packets that are supposed to follow a specific path are indeed
|   being forwarded across and exact set of pre-determined nodes.

NEW:

|   Several deployments use Traffic Engineering, policy routing, Segment
|   Routing (SR), and Service Function Chaining (SFC) [RFC7665] to steer
|   packets through a specific set of nodes.  In certain cases,
|   regulatory obligations or a compliance policy require operators to
|   prove that all packets that are supposed to follow a specific path
|   are indeed being forwarded across and exact set of pre-determined
|   nodes.


------------------------------------------------------------------------


Section 1., paragraph 2:
EXPLANATION: 

OLD:

    If a packet flow is supposed to go through a series of service
    functions or network nodes, it has to be proven that indeed all
    packets of the flow followed the path or service chain or collection
    of nodes specified by the policy.  In case some packets of a flow
    weren't appropriately processed, a verification device should
    determine the policy violation and take corresponding actions
    corresponding to the policy (e.g., drop or redirect the packet, send
|   an alert etc.).  In today's deployments, the proof that a packet
    traversed a particular path or service chain is typically delivered
    in an indirect way: Service appliances and network forwarding are in
    different trust domains.  Physical hand-off-points are defined
    between these trust domains (i.e.  physical interfaces).  Or in other
    terms, in the "network forwarding domain" things are wired up in a
    way that traffic is delivered to the ingress interface of a service
    appliance and received back from an egress interface of a service
    appliance.  This "wiring" is verified and then trusted upon.  The
    evolution to Network Function Virtualization (NFV) and modern service
|   chaining concepts (using technologies such as LISP, NSH, Segment
|   Routing (SR), etc.) blurs the line between the different trust
|   domains, because the hand-off-points are no longer clearly defined
|   physical interfaces, but are virtual interfaces.  As a consequence,
|   different trust layers should not to be mixed in the same device.
|   For an NFV scenario a different type of proof is required.  Offering
|   a proof that a packet indeed traversed a specific set of service
|   functions or nodes allows operators to evolve from the above
|   described indirect methods of proving that packets visit a
|   predetermined set of nodes.

NEW:

    If a packet flow is supposed to go through a series of service
    functions or network nodes, it has to be proven that indeed all
    packets of the flow followed the path or service chain or collection
    of nodes specified by the policy.  In case some packets of a flow
    weren't appropriately processed, a verification device should
    determine the policy violation and take corresponding actions
    corresponding to the policy (e.g., drop or redirect the packet, send
|   an alert etc.)  In today's deployments, the proof that a packet
    traversed a particular path or service chain is typically delivered
    in an indirect way: Service appliances and network forwarding are in
    different trust domains.  Physical hand-off-points are defined
    between these trust domains (i.e.  physical interfaces).  Or in other
    terms, in the "network forwarding domain" things are wired up in a
    way that traffic is delivered to the ingress interface of a service
    appliance and received back from an egress interface of a service
    appliance.  This "wiring" is verified and then trusted upon.  The
    evolution to Network Function Virtualization (NFV) and modern service
|   chaining concepts (using technologies such as Locator/ID Separation
|   Protocol (LISP), Network Service Header (NSH), Segment Routing (SR),
|   etc.) blurs the line between the different trust domains, because the
|   hand-off-points are no longer clearly defined physical interfaces,
|   but are virtual interfaces.  As a consequence, different trust layers
|   should not to be mixed in the same device.  For an NFV scenario a
|   different type of proof is required.  Offering a proof that a packet
|   indeed traversed a specific set of service functions or nodes allows
|   operators to evolve from the above described indirect methods of
|   proving that packets visit a predetermined set of nodes.


------------------------------------------------------------------------


Section 1., paragraph 3:
EXPLANATION: 

OLD:

    The solution approach presented in this document is based on a small
|   portion of operational data added to every packet.  This "in-band"
    operational data is also referred to as "proof of transit data", or
    POT data.  The POT data is updated at every required node and is used
    to verify whether a packet traversed all required nodes.  A
    particular set of nodes "to be verified" is either described by a set
    of secret keys, or a set of shares of a single secret.  Nodes on the
    path retrieve their individual keys or shares of a key (using for
    e.g., Shamir's Secret Sharing scheme) from a central controller.  The
    complete key set is only known to the controller and a verifier node,
    which is typically the ultimate node on a path that performs
    verification.  Each node in the path uses its secret or share of the
    secret to update the POT data of the packets as the packets pass
    through the node.  When the verifier receives a packet, it uses its
    key(s) along with data found in the packet to validate whether the
    packet traversed the path correctly.

NEW:

    The solution approach presented in this document is based on a small
|   portion of operational data added to every packet.  This "in-situ"
    operational data is also referred to as "proof of transit data", or
    POT data.  The POT data is updated at every required node and is used
    to verify whether a packet traversed all required nodes.  A
    particular set of nodes "to be verified" is either described by a set
    of secret keys, or a set of shares of a single secret.  Nodes on the
    path retrieve their individual keys or shares of a key (using for
    e.g., Shamir's Secret Sharing scheme) from a central controller.  The
    complete key set is only known to the controller and a verifier node,
    which is typically the ultimate node on a path that performs
    verification.  Each node in the path uses its secret or share of the
    secret to update the POT data of the packets as the packets pass
    through the node.  When the verifier receives a packet, it uses its
    key(s) along with data found in the packet to validate whether the
    packet traversed the path correctly.


------------------------------------------------------------------------


Section 2., paragraph 2:
EXPLANATION: 

OLD:

    MTU:       Maximum Transmit Unit

NEW:

|   LISP:      Locator/ID Separation Protocol
|
|   LPC:       Lagrange Polynomial Constants
|
    MTU:       Maximum Transmit Unit


------------------------------------------------------------------------


Section 2., paragraph 3:
EXPLANATION: 

OLD:

|   SR:        Segment Routing

NEW:

|   NFV:       Network Function Virtualization


------------------------------------------------------------------------


Section 2., paragraph 5:
EXPLANATION: 

OLD:

|   SFC:       Service Function Chain
|
    POT:       Proof of Transit

NEW:

    POT:       Proof of Transit


------------------------------------------------------------------------


Section 3., paragraph 0:
EXPLANATION: 

OLD:

 3.  Proof of Transit

NEW:

|   SFC:       Service Function Chain
|
|   SR:        Segment Routing
|
 3.  Proof of Transit


------------------------------------------------------------------------


Section 3., paragraph 2:
EXPLANATION: 

OLD:

    The methods how traffic is identified and associated to a specific
    path is outside the scope of this document.  Identification could be
|   done using a filter (e.g., 5-tupel classifier), or an identifier
    which is already present in the packet (e.g., path or service
|   identifier, flow-label, etc.).

NEW:

    The methods how traffic is identified and associated to a specific
    path is outside the scope of this document.  Identification could be
|   done using a filter (e.g., 5-tuple classifier), or an identifier
    which is already present in the packet (e.g., path or service
|   identifier, NSH Service Path Identifier (SPI), flow-label, etc.)


------------------------------------------------------------------------


Section 3.1., paragraph 1:
EXPLANATION: 

OLD:

    The method relies on adding POT data to all packets that traverse a
    path.  The added POT data allows a verifying node (egress node) to
    check whether a packet traversed the identified set of nodes on a
    path correctly or not.  Security mechanisms are natively built into
    the generation of the POT data to protect against misuse (i.e.
    configuration mistakes, malicious administrators playing tricks with
    routing, capturing, spoofing and replaying packets).  The mechanism
|   for POT leverages "Shamir's secret sharing scheme" [SSS].

NEW:

    The method relies on adding POT data to all packets that traverse a
    path.  The added POT data allows a verifying node (egress node) to
    check whether a packet traversed the identified set of nodes on a
    path correctly or not.  Security mechanisms are natively built into
    the generation of the POT data to protect against misuse (i.e.
    configuration mistakes, malicious administrators playing tricks with
    routing, capturing, spoofing and replaying packets).  The mechanism
|   for POT leverages "Shamir's Secret Sharing" scheme [SSS].


------------------------------------------------------------------------


Section 3.1., paragraph 2:
EXPLANATION: 

OLD:

    Shamir's secret sharing base idea: A polynomial (represented by its
|   co-efficients) is chosen as a secret by the controller.  A polynomial
|   represents a curve.  A set of well defined points on the curve are
    needed to construct the polynomial.  Each point of the polynomial is
    called "share" of the secret.  A single secret is associated with a
    particular set of nodes, which typically represent the path, to be
    verified.  Shares of the single secret (i.e., points on the curve)
    are securely distributed from a Controller to the network nodes.
    Nodes use their respective share to update a cumulative value in the
    POT data of each packet.  Only a verifying node has access to the
    complete secret.  The verifying node validates the correctness of the
    received POT data by reconstructing the curve.

NEW:

    Shamir's secret sharing base idea: A polynomial (represented by its
|   coefficients) is chosen as a secret by the controller.  A polynomial
|   represents a curve.  A set of well-defined points on the curve are
    needed to construct the polynomial.  Each point of the polynomial is
    called "share" of the secret.  A single secret is associated with a
    particular set of nodes, which typically represent the path, to be
    verified.  Shares of the single secret (i.e., points on the curve)
    are securely distributed from a Controller to the network nodes.
    Nodes use their respective share to update a cumulative value in the
    POT data of each packet.  Only a verifying node has access to the
    complete secret.  The verifying node validates the correctness of the
    received POT data by reconstructing the curve.


------------------------------------------------------------------------


Section 3.2.2., paragraph 1:
EXPLANATION: 

OLD:

|   For each packet, the source node generates a random number (RND).  It
|   is considered as the constant coefficient for POLY-2.  A cumulative
|   value (CML) is initialized to 0.  Both RND, CML are carried as within
|   the packet POT data.  As the packet visits each node, the RND is
|   retrieved from the packet and the respective share of POLY-2 is
|   calculated.  Each node calculates (Share(POLY-1)+Share(POLY-2)) and
|   CML is updated with this sum.  This step is performed by each node
|   until the packet completes the path.  The verifier also performs the
|   step with its respective share.

NEW:

|   For each packet, the ingress node generates a random number (RND).
|   It is considered as the constant coefficient for POLY-2.  A
|   cumulative value (CML) is initialized to 0.  Both RND, CML are
|   carried as within the packet POT data.  As the packet visits each
|   node, the RND is retrieved from the packet and the respective share
|   of POLY-2 is calculated.  Each node calculates (Share(POLY-1) +
|   Share(POLY-2)) and CML is updated with this sum.  This step is
|   performed by each node until the packet completes the path.  The
|   verifier also performs the step with its respective share.


------------------------------------------------------------------------


Section 3.2.3., paragraph 2:
EXPLANATION: 

OLD:

|3.3.  Example for Illustration

NEW:

|3.3.  Illustrative Example


------------------------------------------------------------------------


Section 3.3.1., paragraph 1:
EXPLANATION: 

OLD:

|   Assumption: We like to verify that packets pass through 3 nodes.
|   Consequently we need a polynomial of degree 2.

NEW:

|   Assumption: It is to be verified whether packets passed through 3
|   nodes.  A polynomial of degree 2 is chosen for verification.


------------------------------------------------------------------------


Section 3.3.1.1., paragraph 1:
EXPLANATION: 

OLD:

    The shares of the secret are the points on POLY-1 chosen for the 3
|   nodes.  Here we use x0=2, x1=4, x2=5.

NEW:

    The shares of the secret are the points on POLY-1 chosen for the 3
|   nodes.  For example, let x0=2, x1=4, x2=5.


------------------------------------------------------------------------


Section 3.3.1.3., paragraph 1:
EXPLANATION: 

OLD:

    Since x0=2, x1=4, x2=5 are chosen points.  Given that computations
    are done over a finite arithmetic field ("modulo a prime number"),
|   the Lagrange basis polynomial constants (LPC) are computed modulo 53.
|   The Lagrange polynomial constant (LPC) would be 10/3 , -5 , 8/3.

NEW:

    Since x0=2, x1=4, x2=5 are chosen points.  Given that computations
    are done over a finite arithmetic field ("modulo a prime number"),
|   the Lagrange basis polynomial constants are computed modulo 53.  The
|   Lagrange Polynomial Constant (LPC) would be 10/3 , -5 , 8/3.


------------------------------------------------------------------------


Section 3.3.1.4., paragraph 1:
EXPLANATION: 

OLD:

|   Reconstruction of the polynomial is well defined as

NEW:

|   Reconstruction of the polynomial is well-defined as


------------------------------------------------------------------------


Section 3.3.1.4., paragraph 2:
EXPLANATION: 

OLD:

|   POLY1(x) = l0(x)*y0 + l1(x)*y1 + l2(x)*y2.

NEW:

|   POLY1(x) = l0(x) * y0 + l1(x) * y1 + l2(x) * y2


------------------------------------------------------------------------


Section 3.3.1.4., paragraph 4:
EXPLANATION: 

OLD:

|   SECRET = (y0*LPC(l0)+y1*LPC(l1)+y2*LPC(l2)) mod 53.

NEW:

|   SECRET = (y0*LPC(l0)+y1*LPC(l1)+y2*LPC(l2)) mod 53


------------------------------------------------------------------------


Section 3.3.1.4., paragraph 6:
EXPLANATION: 

OLD:

    SECRET = (y0*LPC(l0) + y1*LPC(l1) + y2*LPC(l2)) mod 53 = mod (28 * 21
|   + 17 * 48 + 47 * 38) mod 53 = 3190 mod 53 = 10.

NEW:

    SECRET = (y0*LPC(l0) + y1*LPC(l1) + y2*LPC(l2)) mod 53 = mod (28 * 21
|   + 17 * 48 + 47 * 38) mod 53 = 3190 mod 53 = 10


------------------------------------------------------------------------


Section 3.3.2., paragraph 1:
EXPLANATION: 

OLD:

    As observed previously, the vanilla algorithm that involves a single
|   secret polynomial is not secure.  We enhance the solution with usage
|   of a random second polynomial chosen per packet.

NEW:

    As observed previously, the vanilla algorithm that involves a single
|   secret polynomial is not secure.  Therefore, the solution is further
|   enhanced with usage of a random second polynomial chosen per packet.


------------------------------------------------------------------------


Section 3.3.2.1., paragraph 1:
EXPLANATION: 

OLD:

    Let the second polynomial POLY-2 be (RND + 7x + 10 x^2).  RND is a
    random number and is generated for each packet.  Note that POLY-2 is
    public and need not be kept secret.  The nodes can be pre-configured
    with the non-constant coefficients (for example, 7 and 10 in this
|   case could be configured through the Controller on each node).

NEW:

    Let the second polynomial POLY-2 be (RND + 7x + 10 x^2).  RND is a
    random number and is generated for each packet.  Note that POLY-2 is
    public and need not be kept secret.  The nodes can be pre-configured
    with the non-constant coefficients (for example, 7 and 10 in this
|   case could be configured through the Controller on each node).  So
|   precisely only RND value changes per packet and is public and the
|   rest of the non-constant coefficients of POLY-2 kept secret.


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 2:
EXPLANATION: 

OLD:

|   CML = CML+(((Share(POLY-1)+ Share(POLY-2)) * LPC) mod Prime.

NEW:

|   CML = CML+(((Share(POLY-1)+ Share(POLY-2)) * LPC) mod Prime


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 3:
EXPLANATION: 

OLD:

|   Lets observe the packet level transformations in detail.  For the
    example packet here, let the value RND be 45.  Thus POLY-2 would be
    (45 + 7x + 10x^2).

NEW:

|   Let us observe the packet level transformations in detail.  For the
    example packet here, let the value RND be 45.  Thus POLY-2 would be
    (45 + 7x + 10x^2).


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 5:
EXPLANATION: 

OLD:

|      At source: The fields RND = 45.  CML = 0.
|
|      At node-1 (x0): Respective share of POLY-2 is generated i.e (2,46)
|      because share index of node-1 is 2.

NEW:

|      At ingress: The fields RND = 45.  CML = 0.


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 6:
EXPLANATION: 

OLD:

|      CML = 0 + ((28 + 46)* 21) mod 53 = 17.

NEW:

|      At node-1 (x0): Respective share of POLY-2 is generated i.e., (2,
|      46) because share index of node-1 is 2.


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 7:
EXPLANATION: 

OLD:

|      At node-2 (x1): Respective share of POLY-2 is generated i.e (4,21)
|      because share index of node-2 is 4.

NEW:

|      CML = 0 + ((28 + 46)* 21) mod 53 = 17
|      At node-2 (x1): Respective share of POLY-2 is generated i.e., (4,
|      21) because share index of node-2 is 4.


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 8:
EXPLANATION: 

OLD:

|      CML = 17 + ((17 + 21)*48) mod 53 = 17 + 22 = 39.

NEW:

|      CML = 17 + ((17 + 21)*48) mod 53 = 17 + 22 = 39


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 9:
EXPLANATION: 

OLD:

       At node-3 (x2), which is also the verifier: The respective share
|      of POLY-2 is generated i.e (5,12) because the share index of the
|      verifier is 12.

NEW:

       At node-3 (x2), which is also the verifier: The respective share
|      of POLY-2 is generated i.e., (5, 12) because the share index of
|      the verifier is 12.


------------------------------------------------------------------------


Section 3.3.2.2., paragraph 10:
EXPLANATION: 

OLD:

       CML = 39 + ((47 + 12)*38) mod 53 = 39 + 16 = 55 mod 53 = 2
    The verification using CML is discussed in next section.

NEW:

       CML = 39 + ((47 + 12)*38) mod 53 = 39 + 16 = 55 mod 53 = 2
|
    The verification using CML is discussed in next section.


------------------------------------------------------------------------


Section 3.3.2.3., paragraph 2:
EXPLANATION: 

OLD:

|   VERIFY = (SECRET + RND) mod Prime, with Prime = 53 here.

NEW:

|   VERIFY = (SECRET + RND) mod Prime, with Prime = 53 here


------------------------------------------------------------------------


Section 3.3.2.3., paragraph 3:
EXPLANATION: 

OLD:

|   VERIFY = (RND-1 + RND-2) mod Prime = ( 10 + 45 ) mod 53 = 2.

NEW:

|   VERIFY = (RND-1 + RND-2) mod Prime = ( 10 + 45 ) mod 53 = 2


------------------------------------------------------------------------


Section 1., paragraph 0:
EXPLANATION: 

OLD:

    1.  The points (x,y) for each of the nodes on the public and private
        polynomials are picked such that the x component of the points
        match.  This lends to the LPC values which are used to calculate
        the cumulative value CML to be constant.  Note that the LPC are
|       only depending on the x components.  The can be computed at the
        controller and communicated to the nodes.  Otherwise, one would
        need to distributed the x components to all the nodes.

NEW:

    1.  The points (x,y) for each of the nodes on the public and private
        polynomials are picked such that the x component of the points
        match.  This lends to the LPC values which are used to calculate
        the cumulative value CML to be constant.  Note that the LPC are
|       only depending on the x components.  They can be computed at the
        controller and communicated to the nodes.  Otherwise, one would
        need to distributed the x components to all the nodes.


------------------------------------------------------------------------


Section 2., paragraph 0:
EXPLANATION: 

OLD:

    2.  A pre-evaluated portion of the public polynomial for each of the
        nodes is calculated and added to the POT-profile.  Without this
        all the coefficients of the public polynomial had to be added to
|       the POT profile and each node had to evaluate them.

NEW:

    2.  A pre-evaluated portion of the public polynomial for each of the
        nodes is calculated and added to the POT-profile.  Without this
        all the coefficients of the public polynomial had to be added to
|       the POT profile and each node had to evaluate them.  As stated
|       before, the public portion is only the constant coefficient RND
|       value, the pre-evaluated portion for each node should be kept
|       secret as well.


------------------------------------------------------------------------


Section 4., paragraph 0:
EXPLANATION: 

OLD:

 4.  Sizing the Data for Proof of Transit

NEW:

|3.5.  Alternative Approach
|
|   In certain scenarios preserving the order of the nodes traversed by
|   the packet may be needed.  An alternative, "nested encryption" based
|   approach is described here for preserving the order
|
|3.5.1.  Basic Idea
|
|   1.  The controller provisions all the nodes with their respective
|       secret keys.
|
|   2.  The controller provisions the verifier with all the secret keys
|       of the nodes.
|
|   3.  For each packet, the ingress node generates a random number RND
|       and encrypts it with its secret key to generate CML value
|
|   4.  Each subsequent node on the path encrypts CML with their
|       respective secret key and passes it along
|
|   5.  The verifier is also provisioned with the expected sequence of
|       nodes in order to verify the order
|
|   6.  The verifier receives the CML, RND values, re-encrypts the RND
|       with keys in the same order as expected sequence to verify.
|
|3.5.2.  Pros
|
|   Nested encryption approach retains the order in which the nodes are
|   traversed.
|
|3.5.3.  Cons
|
|   1.  Standard AES encryption would need 128 bits of RND, CML.  This
|       results in a 256 bits of additional overhead is added per packet
|
|   2.  In hardware platforms that do not support native encryption
|       capabilities like (AES-NI).  This approach would have
|       considerable impact on the computational latency
|
 4.  Sizing the Data for Proof of Transit


------------------------------------------------------------------------


Section 5.1., paragraph 1:
EXPLANATION: 

OLD:

    The Controller creates new POT-profiles at a constant rate and
    communicates the POT-profile to the nodes.  The controller labels a
    POT-profile "even" or "odd" and the Controller cycles between "even"
    and "odd" labeled profiles.  The rate at which the POT-profiles are
    communicated to the nodes is configurable and is more frequent than
    the speed at which a POT-profile is "used up" (see table above).
    Once the POT-profile has been successfully communicated to all nodes
|   (e.g., all Netconf transactions completed, in case Netconf is used as
    a protocol), the controller sends an "enable POT-profile" request to
    the ingress node.

NEW:

    The Controller creates new POT-profiles at a constant rate and
    communicates the POT-profile to the nodes.  The controller labels a
    POT-profile "even" or "odd" and the Controller cycles between "even"
    and "odd" labeled profiles.  The rate at which the POT-profiles are
    communicated to the nodes is configurable and is more frequent than
    the speed at which a POT-profile is "used up" (see table above).
    Once the POT-profile has been successfully communicated to all nodes
|   (e.g., all NETCONF transactions completed, in case NETCONF is used as
    a protocol), the controller sends an "enable POT-profile" request to
    the ingress node.


------------------------------------------------------------------------


Section 5.2., paragraph 9:
EXPLANATION: 

OLD:

      revision 2016-06-15 {
        description
          "Initial revision.";
        reference
          "";
      }
|
      typedef profile-index-range {
        type int32 {
          range "0 .. 1";
        }
        description
          "Range used for the profile index. Currently restricted to
           0 or 1 to identify the odd or even profiles.";
      }

NEW:

      revision 2016-06-15 {
        description
          "Initial revision.";
        reference
          "";
      }
      typedef profile-index-range {
        type int32 {
          range "0 .. 1";
        }
        description
          "Range used for the profile index. Currently restricted to
           0 or 1 to identify the odd or even profiles.";
      }


------------------------------------------------------------------------


Section 8.1., paragraph 3:
EXPLANATION: 

OLD:

|   o  The Shares of the SECRET (i.e., points on POLY-1 ) are kept secret
|      by individual nodes.
|
    An attacker bypassing a few nodes will miss adding a respective point
    on POLY-1 to corresponding point on POLY-2 , thus the verifier cannot
    construct POLY-3 for cross verification.

NEW:

|   o  Precisely three values are kept secret by individual nodes.  Share
|      of SECRET (i.e. points on POLY-1), Share of POLY-2, LPC, P.  Note
|      that only constant coefficient, RND, of POLY-2 is public. x values
|      and non-constant coefficient of POLY-2 are secret
    An attacker bypassing a few nodes will miss adding a respective point
    on POLY-1 to corresponding point on POLY-2 , thus the verifier cannot
    construct POLY-3 for cross verification.


------------------------------------------------------------------------


Section 8.1., paragraph 4:
EXPLANATION: 

OLD:

|8.2.  Anti Replay

NEW:

|   Also it is highly recommended that different polynomials should be
|   used as POLY-1 across different paths, traffic profiles or service
|   chains.


------------------------------------------------------------------------


Section 8.1., paragraph 5:
EXPLANATION: 

OLD:

|   A passive attacker observing CML values across nodes (i.e., as the
|   packets entering and leaving), cannot perform differential analysis
|   to construct the points on POLY-1 as the operations are done modulo
|   prime.  The solution approach is flexible, one could use different
|   points on POLY-1 or different polynomials as POLY-1 across different
|   paths, traffic profiles or service chains.

NEW:

|8.2.  Cryptanalysis


------------------------------------------------------------------------


Section 8.1., paragraph 6:
EXPLANATION: 

OLD:

|   Doing differential analysis across packets could be mitigated with
|   POLY-2 being be random.  Further an attacker could reuse a set of RND
|   and all the intermediate CML values to bypass certain nodes in later
|   packets.  Such attacks could be avoided by carefully choosing POLY-2
|   as a timestamp concatenated with a random string.  The verifier could
|   use the timestamp to mitigate reuse within a time window.

NEW:

|   A passive attacker could try to harvest the POT data (i.e., CML, RND
|   values) in order to determine the configured secrets.  Subsequently
|   two types of differential analysis for guessing the secrets could be
|   done.


------------------------------------------------------------------------


Section 8.1., paragraph 7:
EXPLANATION: 

OLD:

|8.3.  Anti Tampering

NEW:

|   o  Inter-Node: A passive attacker observing CML values across nodes
|      (i.e., as the packets entering and leaving), cannot perform
|      differential analysis to construct the points on POLY-1.  This is
|      because at each point there are four unknowns (i.e.  Share(POLY-
|      1), Share(Poly-2) LPC and prime number P) and three known values
|      (i.e.  RND, CML-before, CML-after).
|
|   o  Inter-Packets: A passive attacker could observe CML values across
|      packets (i.e., values of PKT-1 and subsequent PKT-2), in order to
|      predict the secrets.  Differential analysis across packets could
|      be mitigated using a good PRNG for generating RND.  Note that if
|      constant coefficient is a sequence number than CML values become
|      quite predictable and the scheme would be broken.
|
|8.3.  Anti-Replay
|
|   A passive attacker could reuse a set of older RND and the
|   intermediate CML values to bypass certain nodes in later packets.
|   Such attacks could be avoided by carefully choosing POLY-2 as a
|   (SEQ_NO + RND).  For example, if 64 bits are being used for POLY-2
|   then first 16 bits could be a sequence number SEQ_NO and next 48 bits
|   could be a random number.
|
|   Subsequently, the verifier could use the SEQ_NO bits to run classic
|   anti-replay techniques like sliding window used in IPSEC.  The
|   verifier could buffer up to 2^16 packets as a sliding window.
|   Packets arriving with a higher SEQ_NO than current buffer could be
|   flagged legitimate.  Packets arriving with a lower SEQ_NO than
|   current buffer could be flagged as suspicious.
|
|   For all practical purposes in the rest of the document RND means
|   SEQ_NO + RND to keep it simple.
|
|8.4.  Anti-Preplay
|
|   An active attacker could try to perform a man-in-the-middle (MITM)
|   attack by extracting the POT of PKT-1 and using it in PKT-2.
|   Subsequently attacker drops the PKT-1 in order to avoid duplicate POT
|   values reaching the verifier.  If the PKT-1 reaches the verifier,
|   then this attack is same as Replay attacks discussed before.
|
|   Preplay attacks are possible since the POT metadata is not dependent
|   on the packet fields.  Below steps are recommended for remediation:
|
|   o  Ingress node and Verifier are configured with common pre shared
|      key
|
|   o  Ingress node generates a Message Authentication Code (MAC) from
|      packet fields using standard HMAC algorithm.  For example, HMAC-
|      SHA256 generates 256 bits of MAC.
|
|   o  The left most bits of the output are truncated to desired length
|      to generate RND.  It is recommended to use a minimum of 32 bits.
|
|   o  The verifier regenerates the HMAC from the packet fields and
|      compares with RND.  To ensure the POT data is in fact that of the
|      packet.
|
|   An active attacker since lacks the knowledge of pre-shared key cannot
|   launch preplay attacks.
|
|8.5.  Anti-Tampering


------------------------------------------------------------------------


Section 8.1., paragraph 9:
EXPLANATION: 

OLD:

|8.4.  Recycling

NEW:

|8.6.  Recycling


------------------------------------------------------------------------


Section 8.1., paragraph 11:
EXPLANATION: 

OLD:

|8.5.  Redundant Nodes and Failover

NEW:

|8.7.  Redundant Nodes and Failover


------------------------------------------------------------------------


Section 8.1., paragraph 13:
EXPLANATION: 

OLD:

|8.6.  Controller Operation

NEW:

|8.8.  Controller Operation


------------------------------------------------------------------------


Section 8.1., paragraph 14:
EXPLANATION: 

OLD:

    The Controller needs to be secured given that it creates and holds
    the secrets, as need to be the nodes.  The communication between
    Controller and the nodes also needs to be secured.  As secure
|   communication protocol such as for example Netconf over SSH should be
    chosen for Controller to node communication.

NEW:

    The Controller needs to be secured given that it creates and holds
    the secrets, as need to be the nodes.  The communication between
    Controller and the nodes also needs to be secured.  As secure
|   communication protocol such as for example NETCONF over SSH should be
    chosen for Controller to node communication.


------------------------------------------------------------------------


Section 3100, paragraph 1:
EXPLANATION: 

OLD:

|8.7.  Verification Scope

NEW:

|8.9.  Verification Scope


------------------------------------------------------------------------


Section 3100, paragraph 3:
EXPLANATION: 

OLD:

|8.7.1.  Node Ordering

NEW:

|8.9.1.  Node Ordering


------------------------------------------------------------------------


Section 3100, paragraph 4:
EXPLANATION: 

OLD:

    POT using Shamir's secret sharing scheme as discussed in this
    document provides for a means to verify that a set of nodes has been
    visited by a data packet.  It does not verify the order in which the
    data packet visited the nodes.  In case the order in which a data
    packet traversed a particular set of nodes needs to be verified as
|   well, alternate schemes that e.g., rely on nested encryption could to
|   be considered.

NEW:

    POT using Shamir's secret sharing scheme as discussed in this
    document provides for a means to verify that a set of nodes has been
    visited by a data packet.  It does not verify the order in which the
    data packet visited the nodes.  In case the order in which a data
    packet traversed a particular set of nodes needs to be verified as
|   well, alternate schemes that e.g., rely on "nested encryption" could
|   to be considered.


------------------------------------------------------------------------


Section 3100, paragraph 5:
EXPLANATION: 

OLD:

|8.7.2.  Stealth Nodes

NEW:

|8.9.2.  Stealth Nodes


------------------------------------------------------------------------


Section 9., paragraph 1:
EXPLANATION: 

OLD:

    The authors would like to thank Eric Vyncke, Nalini Elkins, Srihari
    Raghavan, Ranganathan T S, Karthik Babu Harichandra Babu, Akshaya
|   Nadahalli, and Andrew Yourtchenko for the comments and advice.

NEW:

    The authors would like to thank Eric Vyncke, Nalini Elkins, Srihari
    Raghavan, Ranganathan T S, Karthik Babu Harichandra Babu, Akshaya
|   Nadahalli, Erik Nordmark, and Andrew Yourtchenko for the comments and
|   advice.


------------------------------------------------------------------------


Section 10.1., paragraph 1:
EXPLANATION: 

OLD:

|   [draft-kitamura-ipv6-record-route]
|              Kitamura, H., "Record Route for IPv6 (PR6),Hop-by-Hop
|              Option Extension", November 2000.
|
    [RFC7665]  Halpern, J., Ed. and C. Pignataro, Ed., "Service Function
               Chaining (SFC) Architecture", RFC 7665,
               DOI 10.17487/RFC7665, October 2015,
               <http://www.rfc-editor.org/info/rfc7665>.

NEW:

    [RFC7665]  Halpern, J., Ed. and C. Pignataro, Ed., "Service Function
               Chaining (SFC) Architecture", RFC 7665,
               DOI 10.17487/RFC7665, October 2015,
               <http://www.rfc-editor.org/info/rfc7665>.


------------------------------------------------------------------------


Section 10.2., paragraph 1:
EXPLANATION: 

OLD:

|   [draft-brockners-inband-oam-data]
|              Brockners, F. and S. Bhandari, "Data Formats for in-band
|              OAM", July 2016.
|
|   [draft-brockners-inband-oam-requirements]
|              Brockners, F., Bhandari, S., and S. Dara, "Requirements
|              for in-band OAM", July 2016.
|
|   [draft-brockners-inband-oam-transport]
|              Brockners, F. and S. Bhandari, "Encapsulations for in-band
|              OAM", July 2016.
|
|   [FD.io]    "Fast Data Project: FD.io", <https://fd.io/>.
|
|   [I-D.hildebrand-spud-prototype]
|              Hildebrand, J. and B. Trammell, "Substrate Protocol for
|              User Datagrams (SPUD) Prototype", draft-hildebrand-spud-
|              prototype-03 (work in progress), March 2015.
|
    [I-D.ietf-anima-autonomic-control-plane]
               Behringer, M., Eckert, T., and S. Bjarnason, "An Autonomic
               Control Plane", draft-ietf-anima-autonomic-control-
               plane-03 (work in progress), July 2016.

NEW:

    [I-D.ietf-anima-autonomic-control-plane]
               Behringer, M., Eckert, T., and S. Bjarnason, "An Autonomic
               Control Plane", draft-ietf-anima-autonomic-control-
               plane-03 (work in progress), July 2016.


------------------------------------------------------------------------


Section 10.2., paragraph 2:
EXPLANATION: 

OLD:

|   [P4]       Kim, , "P4: In-band Network Telemetry (INT)", September
|              2015.
|
 Authors' Addresses

NEW:

 Authors' Addresses


------------------------------------------------------------------------


Section 10.2., paragraph 4:
EXPLANATION: 

OLD:

    Email: fbrockne@cisco.com
|
    Shwetha Bhandari
    Cisco Systems, Inc.
    Cessna Business Park, Sarjapura Marathalli Outer Ring Road
    Bangalore, KARNATAKA 560 087
    India

NEW:

    Email: fbrockne@cisco.com
    Shwetha Bhandari
    Cisco Systems, Inc.
    Cessna Business Park, Sarjapura Marathalli Outer Ring Road
    Bangalore, KARNATAKA 560 087
    India


------------------------------------------------------------------------


Section 10.2., paragraph 5:
EXPLANATION: 

OLD:

    Email: shwethab@cisco.com
    Sashank Dara
    Cisco Systems, Inc.
    Cessna Business Park, Sarjapura Marathalli Outer Ring Road
    BANGALORE, Bangalore, KARNATAKA 560 087
    INDIA

NEW:

    Email: shwethab@cisco.com
|
    Sashank Dara
    Cisco Systems, Inc.
    Cessna Business Park, Sarjapura Marathalli Outer Ring Road
    BANGALORE, Bangalore, KARNATAKA 560 087
    INDIA


------------------------------------------------------------------------

